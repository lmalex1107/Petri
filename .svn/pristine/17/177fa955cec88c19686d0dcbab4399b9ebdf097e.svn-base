package model;

import java.awt.Paint;
import java.util.ArrayList;
import java.util.Arrays;

public class Erreichbarkeitsnet {
	ArrayList<ERKnot> erknotlist;
	ArrayList<ERArc> erarclist;
	ERKnot firstERKnot;
	ERKnot actual_ERKnot;
	boolean Doublette = false;
	boolean finity = true;
	
	
	
	
	public Erreichbarkeitsnet (int[] startmarking) {
		erknotlist = new ArrayList<ERKnot> ();
		erarclist = new ArrayList<ERArc> ();
		int[] startmarkingcopy = Arrays.copyOf(startmarking, startmarking.length);
		firstERKnot = new ERKnot(startmarkingcopy);
		erknotlist.add(firstERKnot);
		System.out.println("First-Test");
		testprint();
	}
	
	public int getNumberOfKnots() {
		return this.erknotlist.size() ;
	}
	
	public int getNumberOfArcs() {
		return this.erarclist.size();
	}
	
	public ArrayList<ERKnot> getERknotlist() {
		return this.erknotlist;
	}
	
	public ArrayList<ERArc> getERArclist(){
		return this.erarclist;
	}
	
	public boolean isDublette() {
		return this.Doublette;
		
	}
	
	public void insert_knot2(int[] Marking, int[] ERSuccessor, String TransitionID) {				//Test, ob alle Knoten eingetragen werden.
		String current_label = ERKnot.MarkingToString(Marking);
		String former_label = ERKnot.MarkingToString(ERSuccessor);
		if (find(current_label) == null) {										//Knoten noch nicht vorhanden - einfügen
			ERKnot erknot = new ERKnot(Marking);
			
			
			if (find(former_label) != null) {
				erknot.setSuccessor(find(former_label));
				find(former_label).setPredecessor(erknot);						//Vorgänger, Nachfolger eintragen
				
			}
			erknotlist.add(erknot);
			System.out.println("Knoten zum ersten Mal aufgetaucht.");
		}
		testprint();
		
	}
	
	/**
	 * In der Methode 'insert_knot ('Knoten einfügen') wird eine Liste von Markierungen zur Bildung eines neuen Knotens übergeben.
	 * Die zweite Markierungsliste zeigt an, an welcher Stelle, also an welchen Vorgänger-Knoten, 
	 * der neue Knoten angefügt wird. Außerdem gibt eine ID an, welcher Transitor im zugehörigen Petri-
	 * Netz geschaltet wurde.
	 * @param ERKnot
	 * @param ERSuccessor
	 * @param TransitionID
	 */
	public void insert_knot(int[] Marking, int[] ERSuccessor, String TransitionID) {	//überarbeiten!!!
		String current_label = ERKnot.MarkingToString(Marking);
		String former_label = ERKnot.MarkingToString(ERSuccessor);
		this.Doublette = false;
		
		if (find(current_label) == null) {										//Knoten noch nicht vorhanden - einfügen
			ERKnot erknot = new ERKnot(Marking);
			
			
			if (find(former_label) != null) {
				erknot.setPredecessor(find(former_label));
				find(former_label).setSuccessor(erknot);						//Vorgänger, Nachfolger eintragen
				
				ERArc erarc = new ERArc (TransitionID);
				erarc.setSource(former_label);
				erarc.setTarget(current_label);
				this.erarclist.add(erarc);
				
			}
			erknotlist.add(erknot);
			System.out.println("Knoten zum ersten Mal aufgetaucht.");
		}
		else {																	//Wenn Knoten bereits vorhanden...
			System.out.println("Knoten bereits vorhanden.");
			if (find(former_label) != null) {
				boolean found = false;
				int i = 0;
				do {
					if (find(current_label).getPredecessor().size() > 0) {					//Dieser Teil soll Duplikate ausschließen.
						if (find(current_label).getPredecessor().get(i).getLabel().equals(former_label)) {
							found = true;
							this.Doublette = true;
							System.out.println("Auch Vorgänger-Knoten schon vorhanden.");
						}
						else {
							i++;
						}
					}
					
					
				}
				while ((found == false) && (i < find(current_label).getPredecessor().size()));
				if (found == false) {
					find(current_label).setPredecessor(find(former_label));
					find(former_label).setSuccessor(find(current_label));
					
					ERArc erarc = new ERArc (TransitionID);
					erarc.setSource(find(former_label).getLabel());
					erarc.setTarget(find(current_label).getLabel());
					this.erarclist.add(erarc);
				}
			}
			
		}
		
		
		testprint();
		findingPaths();
	}
	
	
	
	private ERKnot find (String label) {
		ERKnot erknot = null;
		boolean found = false;
		int i = 0;
		do {
			if (this.erknotlist.get(i).getLabel().equals(label)) {
				found = true;
				erknot = this.erknotlist.get(i);
			}
			else {
				i++;
			}
		}
		while ((found == false) && (i < this.erknotlist.size()));
		
		
		return erknot;
	}
	
	/**
	 * Die nachfolgende Methode überprüft, ob der Knoten bereits vorhanden ist
	 * und aktualisiert die vorhandenen Verbindungen zu ebendiesem Knoten.
	 */
	private void complete_connections() {
		
	}
	
	/**
	 * Das Herzstück der Klasse und des gesamten Programmes. Hierin wird überprüft, ob
	 * der Erreichbarkeitsgraph endlich ist oder nicht. Wenn ja, dann wird isinfinity auf true gesetzt
	 * @return
	 */
	public void findingPaths() {
		// boolean finite = false;
		System.out.println("Knoten im Erreichbarkeitsnetz ohne Nachfolger:");
		for (int i = 0; i < this.erknotlist.size(); i++) {
			if (this.erknotlist.get(i).getSuccessor().size() == 0) {
				ArrayList<ERKnot>Path = new ArrayList<ERKnot>();
				Path.add(this.erknotlist.get(i));
				ERKnot actuelle_ERKnot = this.erknotlist.get(i);
				System.out.println(Path.get(Path.size() - 1).getLabel());
				intersection(Path);
			}																			//dabei alle Pfade nehmend.
		}
		System.out.println("-------+++++-----");
		
		//return this.isinfinty;
	}
	
	//Methode, die benötigt wird, wenn der Pfad auf eine Abzweigung stößt 
	private void intersection(ArrayList<ERKnot> Path) {
		if (Path.get(Path.size() - 1).getPredecessor().size() != 0) {
			System.out.println("Schleifentest VI");
			System.out.println(Path.get(Path.size() -1 ).getLabel());
			System.out.println(Path.get(Path.size() - 1).getPredecessor().size());
			for (int i = 0; i < Path.get(Path.size() - 1).getPredecessor().size(); i++) {	
				if (knotalreadyadded (Path, Path.get(Path.size() - 1).getPredecessor().get(i)) == false) {
					ArrayList<ERKnot> new_Path = new ArrayList<ERKnot>();
					for (int j = 0; j < Path.size(); j++) {	
						new_Path.add(Path.get(j));
					}
					new_Path.add(Path.get(Path.size() - 1).getPredecessor().get(i));
					intersection(new_Path);
				}
			}
		}
		else {
			System.out.println("+++++-----++++++");
			System.out.println("Gültiger Pfad gefunden");
			for (int k = 0; k < Path.size(); k++) {
				System.out.println(Path.get(k).getLabel()  + Path.get(k).Testmarking());
			}
			System.out.println("-----+++++------");
			for (int l = 0; l < Path.size() ; l++) {
				System.out.println(Path.get(l).getLabel() + Path.get(l).Testmarking());
				for (int m = l + 1; m < Path.size(); m++) {
					System.out.println("   " + Path.get(m).getLabel() + " " + Path.get(m).Testmarking() );
					System.out.println("   " + m_compare(Path.get(l).getMarking(), Path.get(m).getMarking()));
					if (m_compare(Path.get(l).getMarking(), Path.get(m).getMarking()) == true) {
						this.finity = false;
					}
					
				}
			}
		}
	}
	
	private boolean knotalreadyadded(ArrayList<ERKnot> knotlist, ERKnot erknot){
		boolean knotalreadyadded = false;
		for (int i = 0; i < knotlist.size(); i++) {
			if (knotlist.get(i).getLabel().equals(erknot.getLabel())) {
				knotalreadyadded = true;
				System.out.println("Knoten bereits im Erreichbarkeitsgraph vorhanden");
			}
		}
		
		
		return knotalreadyadded;
	}
	
	public boolean isfinity() {
		return this.finity;
	}
	
	
	public void testprint () {
		System.out.println("");
		System.out.println("aktueller Erreichbarkeitsgraph: ");
		for (int i = 0; i < this.erknotlist.size(); i++) {
			System.out.println(this.erknotlist.get(i).getLabel());
			if (this.erknotlist.get(i).getPredecessor().size() > 0) {
				System.out.println("VORGÄNGER ");
				for (int j = 0; j < this.erknotlist.get(i).getPredecessor().size(); j++) {
					System.out.println("   " + this.erknotlist.get(i).getPredecessor().get(j).getLabel());
				}
			}
			
			
		}
		System.out.println("");
	}
	
	//Die Markierungen zweier Knoten werden verglichen. Das Ergebnis ist true, wenn
	//das m-m'-Kriterium zutrifft.
	public boolean m_compare(int[] marking1, int[] marking2) {				// nach Testen auf private setzen!
		int sum1 = 0;
		int sum2 = 0;
		boolean m_criteria = true;
		
		for (int j = 0; j < marking1.length; j++) {
			sum1 = sum1 + marking1[j];
			sum2 = sum2 + marking2[j];
		}
		
		System.out.println("Summe1: " + sum1);
		System.out.println("Summe2: " + sum2);
		
		if (sum1 > sum2) {
			for (int i = 0; i < marking2.length; i++) {
				if (marking1[i] < marking2[i]) {
					m_criteria = false;
				}
			}
			
		}
		else {
			m_criteria = false;
		}
		
			
				
		return m_criteria;
	}
	
	
	public void m_compareTest() {
		int[] marking1 = new int[3];
		int[] marking2 = new int[3];
		
		marking1[0] = 1;
		marking1[1] = 2;
		marking1[2] = 3;
		//marking1[3] = 1;
		
		marking2[0] = 1;
		marking2[1] = 1;
		marking2[2] = 2;
		//marking2[3] = 0;
		
		System.out.println("Marking1: " + marking1[0] + marking1[1] + marking1[2]);
		System.out.println("Marking2: " + marking2[0] + marking2[1] + marking2[2]);
		
		System.out.println("Ergebnis: " + m_compare(marking1, marking2));
	}
	
	public static void main (String args[]) {
		int[] testmark = new int[4];
		Erreichbarkeitsnet ernet = new Erreichbarkeitsnet(testmark);
		ernet.m_compareTest();
	}
}
