package model;

import java.util.ArrayList;

public class PetriNet {
	private ArrayList<Knot> knotlist;
	private ArrayList<Arc> arclist;
	private Transition actual_transition = null;
	private int[] Marking;
	
	
	/**
	 * Im Konstruktor werden die Listen der Knoten und ihren Verbindungen übergeben.
	 * Es wird aus den Angaben in den Biden Listen ein Petri-Netz erstellt.
	 * @param knotlist
	 * @param arclist
	 */
	public PetriNet(ArrayList<Knot> knotlist, ArrayList<Arc> arclist) {
		this.knotlist = knotlist;										
		this.arclist = arclist;											
		for (int i = 0; i < arclist.size(); i++) {					//jeweils zuweisen von Vorgängern und Nachfolgern
			boolean found = false;
			int j = 0;
			do {
				System.out.println("Petrinet-Konstruktor-Test" + j);
				if (arclist.get(i).getSource().equals(knotlist.get(j).getId())) {
					System.out.println("Test2");
					found = true;
					
				}
				else {
					j++;
				}
			}
			while (found == false);
			
			found = false;
			int k = 0;
			
			do {
				if (arclist.get(i).getTarget().equals(knotlist.get(k).getId())) {
					found = true;
				}
				else {
					k++;
				}
			}
			while (found == false);
			knotlist.get(j).setSuccessor(knotlist.get(k));
			knotlist.get(k).setPredecessor(knotlist.get(j));
		}
		Marking = new int[getNumberOfTokens()];
		
	}
	
	/**
	 * Schalten einer Transition
	 */
	public void firing(String id) {
		boolean found = false;
		int i = 0;
		do {
			if (id.equals(this.knotlist.get(i).getId()) && (this.knotlist.get(i).getClass().toString().equals("model.Transition"))) {					//Suchen der richtigen Transition
				found = true;												//und überprüfen, ob Bedingungen für 
				boolean predecessor_marked = true;							//das Schalten erfüllt sind.
				if ((knotlist.get(i).getPredecessorList().size() > 0) && (knotlist.get(i).getSuccessorList().size() > 0)) {
					for (int j = 0; j < knotlist.get(i).getPredecessorList().size(); j++) {
						if (knotlist.get(i).getPredecessorList().get(j).getMarking() > 0)  {
							
						}
						else { 
							predecessor_marked = false;
						}
					}
					if (predecessor_marked == true) {
						for (int k = 0; k < knotlist.get(i).getPredecessorList().size(); k++ ) {
							knotlist.get(i).getPredecessorList().get(k).plusToken(-1);
						}
						for (int l = 0; l < knotlist.get(i).getSuccessorList().size(); l++) {
							knotlist.get(i).getSuccessorList().get(l).plusToken(1);
						}
					}
					
					
				}
																			//Wenn ja, dann wird geschaltet.
			}
			else {
				i++;
			}
			
			
		}
		while ((found == false) && (i  < knotlist.size()));
		
	}
	
	/**
	 * gibt das komplette Petri-Netz zurück,
	 * d.h. den Graphen mit allen Knoten, jeweils mit Vorgänger
	 * und Nachfolger versehen.
	 * @return this.knotlist
	 */
	public ArrayList<Knot> getcompleteKnotList(){
		return this.knotlist;
	}
	
	public int[] getMarking() {
		return this.Marking;
	}
	
	private void changeMarking() {

		for (int i = 0; i < this.Marking.length; i++) {
			this.Marking[i] = 
		}
	}
	
	private int getNumberOfTokens() {					//Methode zur Ermittlung der Länge der Markierung
		int NumberofTokens = 0;
		for (int i = 0; i < knotlist.size(); i++) {
			if (this.knotlist.get(i).getClass().toString().equals("model.Place"));
			NumberofTokens ++;
		}
		
		return NumberofTokens;
	}
}
