package control;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;

import javax.swing.JTextArea;

import control.file.Parser;
import model.Arc;
import model.Erreichbarkeitsnet;
import model.Knot;
import model.PetriNet;

public class Analyse {
	
	ArrayList<String> textlist;
	File[] xmlfiles;
	File xmlfile;
	
	ArrayList<String> SolutionStrings;
	JTextArea textarea;
	
	PetriNet petrinet;
	
	/**
	 * Konstruktor der Klasse Analyse, um (per Stapelverarbeitung) mehrere Dateien zu analysieren
	 * @param xmlfiles
	 * @param textarea
	 */
	public Analyse(File[] xmlfiles, JTextArea textarea) {
		this.xmlfiles = xmlfiles;
		this.textarea = textarea;
		Arrays.sort(xmlfiles);
	}
	
	/**
	 * Konstruktor der Klasse Analyse, um eine einzige Datei zu analysieren
	 * @param xmlfile
	 * @param textarea
	 */
	public Analyse (File xmlfile, JTextArea textarea) {
		this.xmlfile = xmlfile;
		this.textarea = textarea;
	}
	
	/**
	 * gib das eben 
	 * @return
	 */
	public PetriNet getPetriNet() {
		return this.petrinet;
	}
	
	/**
	 * Diese Methode gibt den berechneten Erreichbarkeitsgraphen zurück, unabhängig davon, ob
	 * dieser endlich oder unendlich (also nur partiell vorhanden) ist.
	 * @return
	 */
	public Erreichbarkeitsnet getERNet() {
		return this.petrinet.getERNet();
	}
	
	/**
	 * Durchführung der Analyse für mehrere Petrinetze, kann in Form einer Stapelverarbeitung aufgerufen werden.
	 */
	public void analyse_ALL() {
		
		for (int i = 0; i < xmlfiles.length; i++) {													//Test
			System.out.println("         ++++++++--------+++++++");									//Test
			System.out.println(xmlfiles[i].getName() + "  started...");								//Test
			String startString = new String (xmlfiles[i].getName() + "    wird analysiert \n");
			this.textarea.append(startString);
			Parser parser = new Parser (xmlfiles[i]);										
			parser.initParser();
			parser.parse();
			ArrayList<Knot> knotlist = parser.getKnotList();
			ArrayList<Arc> arclist = parser.getArcList();
			this.petrinet = new PetriNet(knotlist, arclist);
			this.petrinet.firing_all(this.petrinet.getMarking());
			String SolutionString = new String("");
			if (this.petrinet.isInfinity() == true) {						//Konstruktion des Ausgabestrings für einen endlichen Graphen
				SolutionString = SolutionString + xmlfiles[i].getName() + " ja";
				int numberofknots = this.petrinet.getERNet().getNumberOfKnots();
				int numberofarcs = this.petrinet.getERNet().getNumberOfArcs();
				SolutionString = SolutionString + " " + numberofknots + " / " + numberofarcs + "\n";
				System.out.println(SolutionString);
			}
			else {															//Konstruktion der Ausgabe für einen unendlichen Graphen
				SolutionString = SolutionString + xmlfiles[i].getName() + "   nein ";
				
				SolutionString = SolutionString + Integer.toString(this.petrinet.getERNet().getArcToInfinity().size()) + ":(";
				for (int j = this.petrinet.getERNet().getArcToInfinity().size() - 1; j > 0; j--) {
					SolutionString = SolutionString + this.petrinet.getERNet().getArcToInfinity().get(j).getId() + ",";
				}
				SolutionString = SolutionString + this.petrinet.getERNet().getArcToInfinity().get(0).getId();
				SolutionString = SolutionString + ");";
				
				SolutionString = SolutionString + this.petrinet.getERNet().getInfinityKnots()[1].getLabel();
				SolutionString = SolutionString + this.petrinet.getERNet().getInfinityKnots()[0].getLabel();
				SolutionString = SolutionString + "\n";
				System.out.println(SolutionString);
			}
			
			this.textarea.append(SolutionString);
			this.textarea.append("\n");
		}
		
		
	}
	
	
	/**
	 * Durchführung der Analyse für ein Petrinetz
	 * @return liefert als Ergebnis true, wenn der Erreichbarkeitsgraph des entsprechenden Petrinetzes unbeschränkt ist
	 * @return und false, wenn es sich um einen unbegrenzten Erreichbarkeitsgraphen handelt.
	 */
	public boolean analyse_ONE() {
		
		Parser parser = new Parser (xmlfile);
		parser.initParser();
		parser.parse();
		ArrayList<Knot> knotlist = parser.getKnotList();
		ArrayList<Arc> arclist = parser.getArcList();
		this.petrinet = new PetriNet(knotlist, arclist);
		this.petrinet.firing_all(petrinet.getMarking());
		return this.petrinet.isInfinity();
	}
	
	
	public ArrayList<String> getSolutionStrings () {
		return this.SolutionStrings;
	}
	
	
}
