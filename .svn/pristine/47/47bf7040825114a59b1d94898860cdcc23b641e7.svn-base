package model;

import java.util.ArrayList;

public class Erreichbarkeitsnet {
	ArrayList<ERKnot> erknotlist;
	ERKnot firstERKnot;
	ERKnot actual_ERKnot;
	boolean Doublette = false;
	
	
	
	public Erreichbarkeitsnet (int[] startmarking) {
		erknotlist = new ArrayList<ERKnot> ();
		firstERKnot = new ERKnot(startmarking);
		erknotlist.add(firstERKnot);
		System.out.println("First-Test");
		testprint();
	}
	
	public ArrayList<ERKnot> getERknotlist() {
		return this.erknotlist;
	}
	
	public boolean isDublette() {
		return this.Doublette;
		
	}
	
	public void insert_knot2(int[] Marking, int[] ERSuccessor, String TransitionID) {				//Test, ob alle Knoten eingetragen werden.
		String current_label = ERKnot.MarkingToString(Marking);
		String former_label = ERKnot.MarkingToString(ERSuccessor);
		if (find(current_label) == null) {										//Knoten noch nicht vorhanden - einfügen
			ERKnot erknot = new ERKnot(Marking);
			
			
			if (find(former_label) != null) {
				erknot.setSuccesor(find(former_label));
				find(former_label).setPredecessor(erknot);						//Vorgänger, Nachfolger eintragen
				
			}
			erknotlist.add(erknot);
			System.out.println("Knoten zum ersten Mal aufgetaucht.");
		}
		testprint();
	}
	
	/**
	 * In der Methode 'insert_knot ('Knoten einfügen') wird eine Liste von Markierungen zur Bildung eines neuen Knotens übergeben.
	 * Die zweite Markierungsliste zeigt an, an welcher Stelle, also an welchen Vorgänger-Knoten, 
	 * der neue Knoten angefügt wird. Außerdem gibt eine ID an, welcher Transitor im zugehörigen Petri-
	 * Netz geschaltet wurde.
	 * @param ERKnot
	 * @param ERSuccessor
	 * @param TransitionID
	 */
	public void insert_knot(int[] Marking, int[] ERSuccessor, String TransitionID) {	//überarbeiten!!!
		String current_label = ERKnot.MarkingToString(Marking);
		String former_label = ERKnot.MarkingToString(ERSuccessor);
		this.Doublette = false;
		
		if (find(current_label) == null) {										//Knoten noch nicht vorhanden - einfügen
			ERKnot erknot = new ERKnot(Marking);
			
			
			if (find(former_label) != null) {
				erknot.setSuccesor(find(former_label));
				find(former_label).setPredecessor(erknot);						//Vorgänger, Nachfolger eintragen
				
			}
			erknotlist.add(erknot);
			System.out.println("Knoten zum ersten Mal aufgetaucht.");
		}
		else {																	//Wenn Knoten bereits vorhanden...
			System.out.println("Knoten bereits vorhanden.");
			if (find(former_label) != null) {
				boolean found = false;
				int i = 0;
				do {
					if (find(current_label).getSuccessor().size() > 0) {					//Dieser Teil soll Duplikate ausschließen.
						if (find(current_label).getSuccessor().get(i).getLabel().equals(former_label)) {
							found = true;
							this.Doublette = true;
							System.out.println("Auch Vorgänger-Knoten schon vorhanden.");
						}
						else {
							i++;
						}
					}
					
					
				}
				while ((found == false) && (i < find(current_label).getSuccessor().size()));
				if (found == false) {
					find(current_label).setSuccesor(find(former_label));
					find(former_label).setPredecessor(find(current_label));
				}
			}
			
		}
		
		
		testprint();
		
	}
	
	
	
	private ERKnot find (String label) {
		ERKnot erknot = null;
		boolean found = false;
		int i = 0;
		do {
			if (this.erknotlist.get(i).getLabel().equals(label)) {
				found = true;
				erknot = this.erknotlist.get(i);
			}
			else {
				i++;
			}
		}
		while ((found == false) && (i < this.erknotlist.size()));
		
		
		return erknot;
	}
	
	/**
	 * Die nachfolgende Methode überprüft, ob der Knoten bereits vorhanden ist
	 * und aktualisiert die vorhandenen Verbindungen zu ebendiesem Knoten.
	 */
	private void complete_connections() {
		
	}
	
	/**
	 * Das Herzstück der Klasse und des gesamten Programmes. Hierin wird überprüft, ob
	 * der Erreichbarkeitsgraph endlich ist oder nicht.
	 * @return
	 */
	public boolean isInfinity() {
		boolean finite = false;
		
		
		return finite;
	}
	
	public void testprint () {
		System.out.println("");
		System.out.println("aktueller Erreichbarkeitsgraph: ");
		for (int i = 0; i < this.erknotlist.size(); i++) {
			System.out.println(this.erknotlist.get(i).getLabel());
			if (this.erknotlist.get(i).getSuccessor().size() > 0) {
				System.out.println("VORGÄNGER ");
				for (int j = 0; j < this.erknotlist.get(i).getSuccessor().size(); j++) {
					System.out.println("   " + this.erknotlist.get(i).getSuccessor().get(j).getLabel());
				}
			}
			
			
		}
		System.out.println("");
	}
	
	public boolean m_compare(int[] marking1, int[] marking2) {				// nach Testen auf private setzen!
		boolean m_criteria = true;
			for (int i = 0; i < marking2.length; i++) {
				if (marking1[i] > marking2[i]) {
					m_criteria = false;
				}
			}
				
		return m_criteria;
	}
	
	public void m_compareTest() {
		int[] marking1 = new int[4];
		int[] marking2 = new int[4];
		
		marking1[0] = 2;
		marking1[1] = 1;
		marking1[2] = 1;
		marking1[3] = 1;
		
		marking2[0] = 3;
		marking2[1] = 1;
		marking2[2] = 1;
		marking2[3] = 0;
		
		System.out.println("Marking1: " + marking1[0] + marking1[1] + marking1[2] + marking1[3]);
		System.out.println("Marking2: " + marking2[0] + marking2[1] + marking2[2] + marking2[3]);
		
		System.out.println("Ergebnis: " + m_compare(marking1, marking2));
	}
	
	public static void main (String args[]) {
		int[] testmark = new int[4];
		Erreichbarkeitsnet ernet = new Erreichbarkeitsnet(testmark);
		ernet.m_compareTest();
	}
}
