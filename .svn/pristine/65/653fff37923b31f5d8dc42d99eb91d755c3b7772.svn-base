package model;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;

public class PetriNet {
	private ArrayList<Knot> knotlist;
	private ArrayList<Arc> arclist;
	private ArrayList<Knot> placelist;
	private ArrayList<Knot> transitionlist;
	private Knot actual_transition = null;
	private int[] Marking;
	private int[] former_Marking;
	private Erreichbarkeitsgraph ergraph;
	private int stack = 0;
	
	
	
	
	/**
	 * Im Konstruktor werden die Listen der Knoten und ihren Verbindungen übergeben.
	 * Es wird aus den Angaben in den @Biden Listen ein Petri-Netz erstellt.
	 * @param knotlist
	 * @param arclist
	 */
	public PetriNet(ArrayList<Knot> knotlist, ArrayList<Arc> arclist) {
		this.knotlist = knotlist;
		this.arclist = arclist;
		connectKnots();
		makePlacelist();
		makeTransitionlist();
		Marking = new int[this.placelist.size()];
		changeMarking();
		ergraph = new Erreichbarkeitsgraph(this.Marking);
	}
	
	
	
	
	
	
	
	private Knot find (String id) {
		Knot transition = null;
		boolean found = false;
		int i = 0;
		do {
			if (this.transitionlist.get(i).getId().equals(id)) {
				transition = this.transitionlist.get(i);
			}
			else {
				i++;
			}
		}
		while ((found = false) && i < this.transitionlist.size());
		return transition;
	}
	
 	private void connectKnots() {										
		for (int i = 0; i < arclist.size(); i++) {					//jeweils zuweisen von Vorgängern und Nachfolgern
			boolean found = false;
			int j = 0;
			do {
				System.out.println("Petrinet-Konstruktor-Test" + j);
				if (arclist.get(i).getSource().equals(knotlist.get(j).getId())) {
					System.out.println("Test2");
					found = true;
					
				}
				else {
					j++;
				}
			}
			while (found == false);
			
			found = false;
			int k = 0;
			
			do {
				if (arclist.get(i).getTarget().equals(knotlist.get(k).getId())) {
					found = true;
				}
				else {
					k++;
				}
			}
			while (found == false);
			knotlist.get(j).setSuccessor(knotlist.get(k));
			knotlist.get(k).setPredecessor(knotlist.get(j));
		}
	}
	
	private void makePlacelist() {
		this.placelist = new ArrayList<Knot>();
		for (int i = 0; i < this.knotlist.size(); i++) {
			System.out.println("Test IV");
			if (this.knotlist.get(i).getClass().toString().equals("class model.Place")) {
				System.out.println("Test V");
				this.placelist.add(this.knotlist.get(i));
			}
		}
		Collections.sort(this.placelist);
	}
	
	private void makeTransitionlist() {
		this.transitionlist= new ArrayList<Knot>();
		for (int i = 0; i < this.knotlist.size(); i++) {
			if (this.knotlist.get(i).getClass().toString().equals("class model.Transition")) {
				this.transitionlist.add(this.knotlist.get(i));
			}
		}
	}
	
	/**
	 * Schalten einer Transition
	 */
  	public void firing(String id) {
		if (hasenoughtokens(id) == true) {
			boolean found = false;
			int i = 0;
			do {
				if (id.equals(this.knotlist.get(i).getId()) && (this.knotlist.get(i).getClass().toString().equals("class model.Transition"))) {					//Suchen der richtigen Transition
					found = true;												//und überprüfen, ob Bedingungen für 
					boolean predecessor_marked = true;							//das Schalten erfüllt sind.
					if ((knotlist.get(i).getPredecessorList().size() > 0) && (knotlist.get(i).getSuccessorList().size() > 0)) {
						for (int j = 0; j < knotlist.get(i).getPredecessorList().size(); j++) {
							if (knotlist.get(i).getPredecessorList().get(j).getToken() > 0)  {
								
							}
							else { 
								predecessor_marked = false;
							}
						}
						if (predecessor_marked == true) {
							for (int k = 0; k < knotlist.get(i).getPredecessorList().size(); k++ ) {
								knotlist.get(i).getPredecessorList().get(k).plusToken(-1);
							}
							for (int l = 0; l < knotlist.get(i).getSuccessorList().size(); l++) {
								knotlist.get(i).getSuccessorList().get(l).plusToken(1);
							}
						}
						
						
					}
																				//Wenn ja, dann wird geschaltet.
				}
				else {
					i++;
				}
				
				
			}
			while ((found == false) && (i  < knotlist.size()));
			if (i == knotlist.size()) {											//Wenn die zweite Bedingungen der obrigen Schleife zutrifft,
				i = knotlist.size() - 1;										//muss das eine i wieder abgezogen werden.
			}
			this.actual_transition = find(id);
			changeMarking();
			ergraph.insert_knot(this.Marking, this.former_Marking, this.knotlist.get(i).getId());
		}
		
	}
  	
  	
  	public void firing2(String id) {
  		if (find(id) != null) {
  			if (hasenoughtokens (id)  == true) {
  	  			if (find(id).getPredecessorList() != null) {
  	  				for (int i = 0; i < find(id).getPredecessorList().size(); i++) {
  	  	  				find(id).getPredecessorList().get(i).setToken(-1);
  	  	  			}
  	  			}
  	  			
  	  			if (find(id).getPredecessorList() != null) {
  	  				for (int j = 0; j < find(id).getSuccessorList().size(); j++) {
  	  	  				find(id).getSuccessorList().get(j).setToken(1);
  	  	  			}
  	  			}
  	  			changeMarking();
  				ergraph.insert_knot(this.Marking, this.former_Marking, this.find(id).getId());
  	  		}
  		}
  		
  	}
  	
  	
  	/**
  	 * Durchschalten des Petrigraphen bis ein Ergebnis vorliegt. Dazu werden alle möglichen(!) Zustände
  	 * einmal aufgerufen. Wird für die Stapelverarbeitung benötigt.
  	 */
  	public void firing_all(int[] Marking) {								//"Durchschalten". 
  		setMarking(Marking);
  		testMarkingPrint();
  		if (isfiringpossible() == true) {
  			for (int i = 0; i < this.transitionlist.size(); i++) {
  				if (hasenoughtokens(this.transitionlist.get(i).getId()) == true) {
  					setMarking(Marking);
  					testMarkingPrint();
  					firing(this.transitionlist.get(i).getId());
  					if (isfiringpossible() == true) {
  						int [] newMarking = Arrays.copyOf(this.getMarking(), this.getMarking().length);
  						testMarkingPrint();
  						firing_all(newMarking);
  					}
  				}
  	  		}
  		}
  	}
  	
  	public void firing_allALTERNATIVE (int[] Marking) {
  		ArrayList<int[]>MarkingBackup = new ArrayList<int[]>();	
	  		for (int i = 0; i < transitionlist.size(); i++) {
	  			setMarking(Marking);
	  			if (hasenoughtokens(transitionlist.get(i).getId()) == true) {
	  				firing(this.transitionlist.get(i).getId());
	  				if (isfiringpossible2() == true) {
	  					int[] newMarking = Arrays.copyOf(this.getMarking(), this.getMarking().length);
	  					MarkingBackup.add(this.getMarking());
	  				}
	  			}
	  		}
	  		if (MarkingBackup != null) {
	  			if (MarkingBackup.isEmpty() == false) {
	  				for (int j = 0; j < transitionlist.size(); j++) {
	  					firing_allALTERNATIVE(MarkingBackup.get(j));
	  				}
	  			}
	  		}	
  	}
  	
  	
  	public void firing_all3 (int[] Marking) {
  		for (int i = 0; i < transitionlist.size(); i++) {
  			setMarking(Marking);
  			if (hasenoughtokens(transitionlist.get(i).getId()) == true) {
  				firing2(transitionlist.get(i).getId()); 
  				if (isfiringpossible() == true) {
  					int[] newMarking = Arrays.copyOf(this.getMarking(), this.getMarking().length);
  					firing_all3(newMarking);
  				}
  			}
  		}
  	}
  	
  	
  	
  	private void testMarkingPrint() {
  		System.out.println("M A R K I N G - T E S T");
  		for (int i = 0; i < this.Marking.length; i++) {
  			System.out.println(i + ": " + this.Marking[i]);
  		}
  		System.out.println("M A R K I N G - T E S T    E N D E");
  	}
  	
  	
  	private void setMarking(int[] newMarking) {
  		for (int i = 0; i < this.placelist.size(); i++) {
  			this.placelist.get(i).setToken(newMarking[i]);
  		}
  	}
  	

  	
  	
  	public boolean hasenoughtokens(String id) {	//Kann an einer bestimmten Transition noch geschaltet werden?
  		boolean enoughtokens = true;
  		if (find(id) != null) {
  			System.out.println("Beta-Test");
  			if (find(id).getPredecessorList().size() > 0) {
  	  			for (int i = 0; i < find(id).getPredecessorList().size(); i++) {
  	  	  			if (find(id).getPredecessorList().get(i).getToken() < 1) {
  	  	  				enoughtokens = false;
  	  	  			}
  	  	  		}
  	  		}
  		}
  		
  		
  		
  		return enoughtokens;
  	}
  	
  	
  	
	
 	public boolean isfiringpossible() {								//Kann überhaupt noch geschaltet werden?
 		boolean firingpossible = false;
 		int i = 0;
 		do {
 			int j = 0;
 			do {
 				if(this.transitionlist.get(i).getPredecessorList().size() > 0) {
 					if (this.transitionlist.get(i).getPredecessorList().get(j).getToken() > 0) {
 						firingpossible = true;
 					}
 					else {
 	 					j++;
 	 				}
 				}
 				
 			}
 			while ((firingpossible == false) && (j < this.transitionlist.get(i).getPredecessorList().size()));
 			i++;
 		}
 		while ((firingpossible == false) && (i < this.transitionlist.size()));
 		if (firingpossible == false) {
 			System.out.println("Schalten nicht möglich");
 		}
 		return firingpossible;
 	}
 	
 	
 	public boolean isfiringpossible2() {
 		boolean firingpossible = false;
 		for (int i = 0; i < transitionlist.size(); i++) {
 			if (hasenoughtokens(transitionlist.get(i).getId()) == true) {
 				firingpossible = true;
 			}
 		}
 		return firingpossible;
 	}
 	
	/**
	 * gibt das komplette Petri-Netz zurück,
	 * d.h. den Graphen mit allen Knoten, jeweils mit Vorgänger
	 * und Nachfolger versehen.
	 * @return this.knotlist
	 */
	public ArrayList<Knot> getcompleteKnotList(){
		return this.knotlist;
	}
	
	public int[] getMarking() {
		return this.Marking;
	}
	
	public int[] getFormer_Marking() {
		return this.former_Marking;
	}
	
	private void changeMarking() {
		this.former_Marking = Arrays.copyOf(this.Marking, this.Marking.length);
		
		for (int j = 0; j < this.Marking.length; j++) {
			this.Marking[j] = placelist.get(j).getToken();
		}
	}
	
	public ArrayList<Knot> getTransitionlist(){
		return this.transitionlist;
	}
	
	public ArrayList<Knot> getPlacelist(){
		return this.placelist;
	}
}
